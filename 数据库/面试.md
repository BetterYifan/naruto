1. mysql的隔离级别
    a.读未提交(read uncommitted)
        A事务读到B事务未提交的数据，然后B事务回滚。会有脏读、不可重复读、幻读的风险
    b.读提交(read committed)
        A事务不能读取其他事务已经改动但未commit的数据。会有不可重复读的风险
        事务1读取一行 -> 事务2删除这行且提交 -> 事务1再去读这行，将会获得修改后的数据，两次读取结果不一致    
    c.repeated read
        mysql默认的隔离级别
        事务1已经读取的数据，其他事务无法修改(update或delete)。但是其他事务insert数据，无法保证两次范围查询数据总数一致(无法保证幻读)
        实现：已读数据的共享锁在整个事务期间被持有,单行加锁。无法锁住insert的数据
    d.serializable
        悲观锁实现，读加共享锁，写加排他锁。数据安全但是并发度较差
   
   
2. rr，数据是如何加锁的？(一次封锁or两段锁)
一次封锁：方法开始前，在入口处对要用到的所有数据进行锁住，在方法执行之后，再所有解锁(对数据库不适用，不知道加锁范围)
两段锁：加锁阶段+解锁阶段
加锁阶段：事务在读数据之前申请S锁（共享锁），进行写操作申请X锁（排他锁）。如果获取锁失败，事务进入等待状态
解锁阶段：commit时，释放占有的锁(insert,delete,update)

通过锁机制实现可重复读？
    sql第一次读取数据，将读取的数据加锁（悲观锁，事务A占用数据，其他事务都无法改动），其他事务无法修改这些数据，就可以实现rr。

乐观锁：每行数据加个version号，事务A读出version，事务B修改并提交，version变成version+1,事务A再去读，发现变成version+1，则更新。
